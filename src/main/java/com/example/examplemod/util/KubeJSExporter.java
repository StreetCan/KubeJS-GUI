package com.example.examplemod.util;

import com.example.examplemod.recipe.properties.RecipePropertyLibrary;
import com.example.examplemod.recipe.properties.RecipePropertyState;
import net.minecraft.core.registries.BuiltInRegistries;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.ItemStack;
import net.minecraftforge.items.ItemStackHandler;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

/**
 * Utility class for generating and exporting KubeJS recipe scripts.
 */
public class KubeJSExporter {
    private static final char[] MECHANICAL_KEY_CHARS = (
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz!#$%&*+-/<=>?@^_|~:"
    ).toCharArray();

    /**
     * Generates a KubeJS recipe script from the given parameters.
     */
    public static String generateRecipeScript(String recipeType, String recipeId,
                                               ItemStackHandler inputs, ItemStackHandler outputs,
                                               int activeInputSlots, int activeOutputSlots,
                                               RecipePropertyState propertyState) {
        StringBuilder script = new StringBuilder();

        script.append("// Generated by Recipe Editor GUI\n");
        script.append("ServerEvents.recipes(event => {\n");
        script.append("  event.custom({\n");
        script.append("    type: \"").append(recipeType).append("\",\n");

        RecipePropertyState state = propertyState != null ? propertyState : new RecipePropertyState();
        int beforeLength = script.length();
        RecipePropertyLibrary.appendSelectedProperties(script, recipeType, state, inputs, outputs);
        if (script.length() > beforeLength) {
            script.append('\n');
        }

        // Handle different recipe types
        String lowerType = recipeType.toLowerCase();

        if (lowerType.contains("mechanical_crafting")) {
            generateMechanicalCrafting(script, inputs, outputs, state);
        } else if (lowerType.contains("shaped") || lowerType.contains("crafting_shaped")) {
            generateShapedCrafting(script, inputs, outputs, activeInputSlots, activeOutputSlots, state);
        } else if (lowerType.contains("shapeless") || lowerType.contains("crafting_shapeless")) {
            generateShapelessCrafting(script, recipeType, inputs, outputs, activeInputSlots, activeOutputSlots, state);
        } else if (lowerType.contains("smelting") || lowerType.contains("blasting") ||
                   lowerType.contains("smoking") || lowerType.contains("campfire")) {
            generateSmeltingRecipe(script, inputs, outputs, recipeType, state);
        } else if (lowerType.contains("stonecutting")) {
            generateStonecuttingRecipe(script, inputs, outputs, state);
        } else if (lowerType.contains("smithing")) {
            generateSmithingRecipe(script, inputs, outputs, state);
        } else {
            // Generic recipe format
            generateGenericRecipe(script, recipeType, inputs, outputs, activeInputSlots, activeOutputSlots, state);
        }

        script.append("  }).id(\"kubejs:").append(recipeId).append("\");\n");
        script.append("});\n");

        return script.toString();
    }

    private static void generateMechanicalCrafting(StringBuilder script, ItemStackHandler inputs,
                                                   ItemStackHandler outputs, RecipePropertyState state) {
        final int gridSize = 9;
        final int totalSlots = gridSize * gridSize;

        script.append("        pattern: [\n");
        for (int row = 0; row < gridSize; row++) {
            script.append("            \"");
            for (int col = 0; col < gridSize; col++) {
                int slotIndex = row * gridSize + col;
                ItemStack stack = inputs.getStackInSlot(slotIndex);
                if (!stack.isEmpty()) {
                    script.append(getMechanicalKeyChar(slotIndex));
                } else {
                    script.append(' ');
                }
            }
            script.append("\"");
            if (row < gridSize - 1) {
                script.append(',');
            }
            script.append("\n");
        }
        script.append("        ],\n");

        script.append("        key: {\n");
        for (int i = 0; i < totalSlots; i++) {
            ItemStack stack = inputs.getStackInSlot(i);
            if (stack.isEmpty()) {
                continue;
            }

            char keyChar = getMechanicalKeyChar(i);
            String itemId = getItemId(stack);
            int count = resolveSlotCount(state, RecipePropertyLibrary.INGREDIENT_COUNT_ID, i, stack.getCount());

            script.append("            \"").append(keyChar).append("\": { item: \"").append(itemId).append("\"");
            if (count > 1) {
                script.append(", count: ").append(count);
            }
            script.append(" }");

            boolean hasMore = false;
            for (int j = i + 1; j < totalSlots; j++) {
                if (!inputs.getStackInSlot(j).isEmpty()) {
                    hasMore = true;
                    break;
                }
            }
            if (hasMore) {
                script.append(',');
            }
            script.append("\n");
        }
        script.append("        },\n");

        ItemStack resultStack = outputs.getStackInSlot(0);
        if (!resultStack.isEmpty()) {
            String resultId = getItemId(resultStack);
            int resultCount = resolveSlotCount(state, RecipePropertyLibrary.RESULT_COUNT_ID, 0, resultStack.getCount());

            script.append("        result: {\n");
            script.append("            item: \"").append(resultId).append("\",\n");
            script.append("            count: ").append(resultCount).append("\n");
            script.append("        },\n");
        }

        boolean acceptMirrored = resolveAcceptMirrored(state);
        script.append("        acceptMirrored: ").append(acceptMirrored ? "true" : "false").append('\n');
    }

    private static void generateShapedCrafting(StringBuilder script, ItemStackHandler inputs,
                                                ItemStackHandler outputs, int activeInputSlots, int activeOutputSlots,
                                                RecipePropertyState state) {
        script.append("        pattern: [\n");

        // Generate 3x3 pattern
        for (int row = 0; row < 3; row++) {
            script.append("            \"");
            for (int col = 0; col < 3; col++) {
                int index = row * 3 + col;
                ItemStack stack = inputs.getStackInSlot(index);
                if (!stack.isEmpty()) {
                    script.append((char) ('A' + index));
                } else {
                    script.append(' ');
                }
            }
            script.append("\"");
            if (row < 2) script.append(",");
            script.append("\n");
        }
        script.append("        ],\n");

        script.append("        key: {\n");
        for (int i = 0; i < 9; i++) {
            ItemStack stack = inputs.getStackInSlot(i);
            if (!stack.isEmpty()) {
                String itemId = getItemId(stack);
                script.append("            \"").append((char) ('A' + i)).append("\": { item: \"")
                      .append(itemId).append("\"");

                int count = resolveSlotCount(state, RecipePropertyLibrary.INGREDIENT_COUNT_ID, i, stack.getCount());
                if (count > 1) {
                    script.append(", count: ").append(count);
                }
                script.append(" }");

                // Add comma if not last
                boolean hasMore = false;
                for (int j = i + 1; j < 9; j++) {
                    if (!inputs.getStackInSlot(j).isEmpty()) {
                        hasMore = true;
                        break;
                    }
                }
                if (hasMore) script.append(",");
                script.append("\n");
            }
        }
        script.append("        },\n");

        // Add result
        if (activeOutputSlots > 0 && !outputs.getStackInSlot(0).isEmpty()) {
            ItemStack result = outputs.getStackInSlot(0);
            String itemId = getItemId(result);
            int count = resolveSlotCount(state, RecipePropertyLibrary.RESULT_COUNT_ID, 0, result.getCount());
            script.append("        result: { item: \"").append(itemId).append("\"");
            if (count > 1) {
                script.append(", count: ").append(count);
            }
            script.append(" }\n");
        }
    }

    private static void generateShapelessCrafting(StringBuilder script, String recipeType, ItemStackHandler inputs,
                                                   ItemStackHandler outputs, int activeInputSlots, int activeOutputSlots,
                                                   RecipePropertyState state) {
        script.append("    ingredients: [\n");

        for (int i = 0; i < activeInputSlots; i++) {
            ItemStack stack = inputs.getStackInSlot(i);
            if (!stack.isEmpty()) {
                String itemId = getItemId(stack);
                int count = resolveSlotCount(state, RecipePropertyLibrary.INGREDIENT_COUNT_ID, i, stack.getCount());
                script.append("      { item: \"").append(itemId).append("\"");
                if (count > 1) {
                    script.append(", count: ").append(count);
                }
                script.append(" }");

                // Check if there are more items
                boolean hasMore = false;
                for (int j = i + 1; j < activeInputSlots; j++) {
                    if (!inputs.getStackInSlot(j).isEmpty()) {
                        hasMore = true;
                        break;
                    }
                }
                if (hasMore) script.append(",");
                script.append("\n");
            }
        }
        script.append("    ],\n");

        // Add result
        if (activeOutputSlots > 0 && !outputs.getStackInSlot(0).isEmpty()) {
            ItemStack result = outputs.getStackInSlot(0);
            String itemId = getItemId(result);
            int count = resolveSlotCount(state, RecipePropertyLibrary.RESULT_COUNT_ID, 0, result.getCount());
            boolean isCraftingTableRecipe = recipeType.toLowerCase().contains("crafting");

            if (isCraftingTableRecipe) {
                script.append("    result: { item: \"").append(itemId).append("\"");
                if (count > 1) {
                    script.append(", count: ").append(count);
                }
                script.append(" }\n");
            } else {
                script.append("    results: [\n");
                script.append("      { item: \"").append(itemId).append("\"");
                if (count > 1) {
                    script.append(", count: ").append(count);
                }
                script.append(" }");
                script.append("\n    ]\n");
            }
        }
    }

    private static void generateSmeltingRecipe(StringBuilder script, ItemStackHandler inputs,
                                                ItemStackHandler outputs, String recipeType,
                                                RecipePropertyState state) {
        if (!inputs.getStackInSlot(0).isEmpty()) {
            String itemId = getItemId(inputs.getStackInSlot(0));
            script.append("        ingredient: { item: '").append(itemId).append("' },\n");
        }

        if (!outputs.getStackInSlot(0).isEmpty()) {
            ItemStack resultStack = outputs.getStackInSlot(0);
            String itemId = getItemId(resultStack);
            int count = resolveSlotCount(state, RecipePropertyLibrary.RESULT_COUNT_ID, 0, resultStack.getCount());
            script.append("        result: '").append(itemId).append("',\n");
            if (count > 1) {
                script.append("        count: ").append(count).append(",\n");
            }
        }

        // Add experience and cooking time defaults
        script.append("        experience: 0.1,\n");

        if (recipeType.contains("blasting")) {
            script.append("        cookingtime: 100\n");
        } else if (recipeType.contains("smoking")) {
            script.append("        cookingtime: 100\n");
        } else if (recipeType.contains("campfire")) {
            script.append("        cookingtime: 600\n");
        } else {
            script.append("        cookingtime: 200\n");
        }
    }

    private static void generateStonecuttingRecipe(StringBuilder script, ItemStackHandler inputs,
                                                     ItemStackHandler outputs, RecipePropertyState state) {
        if (!inputs.getStackInSlot(0).isEmpty()) {
            String itemId = getItemId(inputs.getStackInSlot(0));
            script.append("        ingredient: { item: '").append(itemId).append("' },\n");
        }

        if (!outputs.getStackInSlot(0).isEmpty()) {
            ItemStack resultStack = outputs.getStackInSlot(0);
            String itemId = getItemId(resultStack);
            int count = resolveSlotCount(state, RecipePropertyLibrary.RESULT_COUNT_ID, 0, resultStack.getCount());
            script.append("        result: '").append(itemId).append("'\n");
            if (count > 1) {
                script.append("        count: ").append(count).append('\n');
            }
        }
    }

    private static void generateSmithingRecipe(StringBuilder script, ItemStackHandler inputs,
                                                ItemStackHandler outputs, RecipePropertyState state) {
        script.append("        base: ");
        if (!inputs.getStackInSlot(1).isEmpty()) {
            String itemId = getItemId(inputs.getStackInSlot(1));
            script.append("{ item: '").append(itemId).append("' }");
        } else {
            script.append("{ item: 'minecraft:air' }");
        }
        script.append(",\n");

        script.append("        addition: ");
        if (!inputs.getStackInSlot(2).isEmpty()) {
            String itemId = getItemId(inputs.getStackInSlot(2));
            script.append("{ item: '").append(itemId).append("' }");
        } else {
            script.append("{ item: 'minecraft:air' }");
        }
        script.append(",\n");

        script.append("        template: ");
        if (!inputs.getStackInSlot(0).isEmpty()) {
            String itemId = getItemId(inputs.getStackInSlot(0));
            script.append("{ item: '").append(itemId).append("' }");
        } else {
            script.append("{ item: 'minecraft:air' }");
        }
        script.append(",\n");

        if (!outputs.getStackInSlot(0).isEmpty()) {
            ItemStack resultStack = outputs.getStackInSlot(0);
            String itemId = getItemId(resultStack);
            int count = resolveSlotCount(state, RecipePropertyLibrary.RESULT_COUNT_ID, 0, resultStack.getCount());
            script.append("        result: { item: '").append(itemId).append("'");
            if (count > 1) {
                script.append(", count: ").append(count);
            }
            script.append(" }\n");
        }
    }

    private static void generateGenericRecipe(StringBuilder script, String recipeType,
                                               ItemStackHandler inputs, ItemStackHandler outputs,
                                               int activeInputSlots, int activeOutputSlots,
                                               RecipePropertyState state) {
        script.append("    ingredients: [\n");

        for (int i = 0; i < activeInputSlots; i++) {
            ItemStack stack = inputs.getStackInSlot(i);
            if (!stack.isEmpty()) {
                String itemId = getItemId(stack);
                int count = resolveSlotCount(state, RecipePropertyLibrary.INGREDIENT_COUNT_ID, i, stack.getCount());
                script.append("      { item: \"").append(itemId).append("\"");
                if (count > 1) {
                    script.append(", count: ").append(count);
                }
                script.append(" }");

                boolean hasMore = false;
                for (int j = i + 1; j < activeInputSlots; j++) {
                    if (!inputs.getStackInSlot(j).isEmpty()) {
                        hasMore = true;
                        break;
                    }
                }
                if (hasMore) script.append(",");
                script.append("\n");
            }
        }
        script.append("    ],\n");

        ResourceLocation typeId = ResourceLocation.tryParse(recipeType);
        boolean isFarmersDelight = typeId != null && "farmersdelight".equals(typeId.getNamespace());
        boolean isCooking = isFarmersDelight && "cooking".equals(typeId.getPath());
        boolean isCutting = isFarmersDelight && "cutting".equals(typeId.getPath());

        if (isCooking) {
            for (int i = 0; i < activeOutputSlots; i++) {
                ItemStack stack = outputs.getStackInSlot(i);
                if (!stack.isEmpty()) {
                    String itemId = getItemId(stack);
                    int count = resolveSlotCount(state, RecipePropertyLibrary.RESULT_COUNT_ID, i, stack.getCount());
                    script.append("    result: { item: \"").append(itemId).append("\"");
                    if (count > 1) {
                        script.append(", count: ").append(count);
                    }
                    script.append(" }\n");
                    break;
                }
            }
            return;
        }

        String outputField = isCutting ? "result" : "results";
        script.append("    ").append(outputField).append(": [\n");
        for (int i = 0; i < activeOutputSlots; i++) {
            ItemStack stack = outputs.getStackInSlot(i);
            if (!stack.isEmpty()) {
                String itemId = getItemId(stack);
                int count = resolveSlotCount(state, RecipePropertyLibrary.RESULT_COUNT_ID, i, stack.getCount());
                script.append("      { item: \"").append(itemId).append("\"");
                if (count > 1) {
                    script.append(", count: ").append(count);
                }
                script.append(" }");

                boolean hasMore = false;
                for (int j = i + 1; j < activeOutputSlots; j++) {
                    if (!outputs.getStackInSlot(j).isEmpty()) {
                        hasMore = true;
                        break;
                    }
                }
                if (hasMore) script.append(",");
                script.append("\n");
            }
        }
        script.append("    ]\n");
    }

    private static String getItemId(ItemStack stack) {
        ResourceLocation id = BuiltInRegistries.ITEM.getKey(stack.getItem());
        return id.toString();
    }

    private static int resolveSlotCount(RecipePropertyState state, String propertyId, int slotIndex, int fallback) {
        if (state == null) {
            return Math.max(fallback, 1);
        }

        String override = state.getSlotValue(propertyId, slotIndex);
        if (override == null || override.isBlank()) {
            return Math.max(fallback, 1);
        }

        try {
            int parsed = Integer.parseInt(override);
            return parsed > 0 ? parsed : Math.max(fallback, 1);
        } catch (NumberFormatException ex) {
            return Math.max(fallback, 1);
        }
    }

    private static char getMechanicalKeyChar(int index) {
        if (index >= 0 && index < MECHANICAL_KEY_CHARS.length) {
            return MECHANICAL_KEY_CHARS[index];
        }
        return (char) ('A' + (index % 26));
    }

    private static boolean resolveAcceptMirrored(RecipePropertyState state) {
        if (state == null) {
            return false;
        }
        int index = state.getOptionIndex(RecipePropertyLibrary.CREATE_ACCEPT_MIRRORED_ID);
        return index >= 1;
    }

    /**
     * Exports the script to a file in the kubejs/server_scripts directory.
     */
    public static boolean exportToFile(String script, String recipeId) {
        try {
            // Get the game directory
            File gameDir = new File(".");
            File kubeJSDir = new File(gameDir, "kubejs");
            File serverScriptsDir = new File(kubeJSDir, "server_scripts");

            // Create directories if they don't exist
            if (!serverScriptsDir.exists()) {
                serverScriptsDir.mkdirs();
            }

            // Write the script file
            File scriptFile = new File(serverScriptsDir, recipeId + ".js");
            try (FileWriter writer = new FileWriter(scriptFile)) {
                writer.write(script);
            }

            System.out.println("Recipe exported to: " + scriptFile.getAbsolutePath());
            return true;

        } catch (IOException e) {
            System.err.println("Failed to export recipe: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }
}
